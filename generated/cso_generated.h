// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CSO_CSOFB_H_
#define FLATBUFFERS_GENERATED_CSO_CSOFB_H_

#include "flatbuffers/flatbuffers.h"

namespace csofb {

struct CompiledShaderFb;

struct CollectionFb;

enum EVersionFb {
  EVersionFb_Value = 1,
  EVersionFb_MIN = EVersionFb_Value,
  EVersionFb_MAX = EVersionFb_Value
};

inline EVersionFb (&EnumValuesEVersionFb())[1] {
  static EVersionFb values[] = {
    EVersionFb_Value
  };
  return values;
}

inline const char **EnumNamesEVersionFb() {
  static const char *names[] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVersionFb(EVersionFb e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(EVersionFb_Value);
  return EnumNamesEVersionFb()[index];
}

enum EShaderType {
  EShaderType_Vert = 0,
  EShaderType_Frag = 1,
  EShaderType_Comp = 2,
  EShaderType_Geom = 3,
  EShaderType_Tesc = 4,
  EShaderType_Tese = 5,
  EShaderType_MIN = EShaderType_Vert,
  EShaderType_MAX = EShaderType_Tese
};

inline EShaderType (&EnumValuesEShaderType())[6] {
  static EShaderType values[] = {
    EShaderType_Vert,
    EShaderType_Frag,
    EShaderType_Comp,
    EShaderType_Geom,
    EShaderType_Tesc,
    EShaderType_Tese
  };
  return values;
}

inline const char **EnumNamesEShaderType() {
  static const char *names[] = {
    "Vert",
    "Frag",
    "Comp",
    "Geom",
    "Tesc",
    "Tese",
    nullptr
  };
  return names;
}

inline const char *EnumNameEShaderType(EShaderType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEShaderType()[index];
}

struct CompiledShaderFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ASSET = 4,
    VT_MACROS = 6,
    VT_SHADER_TYPE = 8,
    VT_SPV = 10
  };
  const flatbuffers::String *asset() const {
    return GetPointer<const flatbuffers::String *>(VT_ASSET);
  }
  const flatbuffers::String *macros() const {
    return GetPointer<const flatbuffers::String *>(VT_MACROS);
  }
  EShaderType shader_type() const {
    return static_cast<EShaderType>(GetField<uint32_t>(VT_SHADER_TYPE, 0));
  }
  const flatbuffers::Vector<uint32_t> *spv() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SPV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ASSET) &&
           verifier.Verify(asset()) &&
           VerifyOffset(verifier, VT_MACROS) &&
           verifier.Verify(macros()) &&
           VerifyField<uint32_t>(verifier, VT_SHADER_TYPE) &&
           VerifyOffset(verifier, VT_SPV) &&
           verifier.Verify(spv()) &&
           verifier.EndTable();
  }
};

struct CompiledShaderFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_asset(flatbuffers::Offset<flatbuffers::String> asset) {
    fbb_.AddOffset(CompiledShaderFb::VT_ASSET, asset);
  }
  void add_macros(flatbuffers::Offset<flatbuffers::String> macros) {
    fbb_.AddOffset(CompiledShaderFb::VT_MACROS, macros);
  }
  void add_shader_type(EShaderType shader_type) {
    fbb_.AddElement<uint32_t>(CompiledShaderFb::VT_SHADER_TYPE, static_cast<uint32_t>(shader_type), 0);
  }
  void add_spv(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> spv) {
    fbb_.AddOffset(CompiledShaderFb::VT_SPV, spv);
  }
  explicit CompiledShaderFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledShaderFbBuilder &operator=(const CompiledShaderFbBuilder &);
  flatbuffers::Offset<CompiledShaderFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledShaderFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledShaderFb> CreateCompiledShaderFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> asset = 0,
    flatbuffers::Offset<flatbuffers::String> macros = 0,
    EShaderType shader_type = EShaderType_Vert,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> spv = 0) {
  CompiledShaderFbBuilder builder_(_fbb);
  builder_.add_spv(spv);
  builder_.add_shader_type(shader_type);
  builder_.add_macros(macros);
  builder_.add_asset(asset);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledShaderFb> CreateCompiledShaderFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *asset = nullptr,
    const char *macros = nullptr,
    EShaderType shader_type = EShaderType_Vert,
    const std::vector<uint32_t> *spv = nullptr) {
  return csofb::CreateCompiledShaderFb(
      _fbb,
      asset ? _fbb.CreateString(asset) : 0,
      macros ? _fbb.CreateString(macros) : 0,
      shader_type,
      spv ? _fbb.CreateVector<uint32_t>(*spv) : 0);
}

struct CollectionFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_CSOS = 6
  };
  EVersionFb version() const {
    return static_cast<EVersionFb>(GetField<uint8_t>(VT_VERSION, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderFb>> *csos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CompiledShaderFb>> *>(VT_CSOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_CSOS) &&
           verifier.Verify(csos()) &&
           verifier.VerifyVectorOfTables(csos()) &&
           verifier.EndTable();
  }
};

struct CollectionFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(EVersionFb version) {
    fbb_.AddElement<uint8_t>(CollectionFb::VT_VERSION, static_cast<uint8_t>(version), 0);
  }
  void add_csos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderFb>>> csos) {
    fbb_.AddOffset(CollectionFb::VT_CSOS, csos);
  }
  explicit CollectionFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CollectionFbBuilder &operator=(const CollectionFbBuilder &);
  flatbuffers::Offset<CollectionFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CollectionFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<CollectionFb> CreateCollectionFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersionFb version = static_cast<EVersionFb>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CompiledShaderFb>>> csos = 0) {
  CollectionFbBuilder builder_(_fbb);
  builder_.add_csos(csos);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<CollectionFb> CreateCollectionFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersionFb version = static_cast<EVersionFb>(0),
    const std::vector<flatbuffers::Offset<CompiledShaderFb>> *csos = nullptr) {
  return csofb::CreateCollectionFb(
      _fbb,
      version,
      csos ? _fbb.CreateVector<flatbuffers::Offset<CompiledShaderFb>>(*csos) : 0);
}

inline const csofb::CollectionFb *GetCollectionFb(const void *buf) {
  return flatbuffers::GetRoot<csofb::CollectionFb>(buf);
}

inline const char *CollectionFbIdentifier() {
  return "SHP ";
}

inline bool CollectionFbBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CollectionFbIdentifier());
}

inline bool VerifyCollectionFbBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<csofb::CollectionFb>(CollectionFbIdentifier());
}

inline const char *CollectionFbExtension() {
  return "shp";
}

inline void FinishCollectionFbBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<csofb::CollectionFb> root) {
  fbb.Finish(root, CollectionFbIdentifier());
}

}  // namespace csofb

#endif  // FLATBUFFERS_GENERATED_CSO_CSOFB_H_
